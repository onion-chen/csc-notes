import{_ as a,c as e,e as p,d as t,r as c,o}from"./app-BPIINpwt.js";const l={};function i(u,n){const s=c("Utterances");return o(),e("div",null,[n[0]||(n[0]=p(`<blockquote><p>本文将帮助你深入理解JavaScript中的变量和函数提升机制，掌握代码执行顺序的底层原理，避免开发中的常见陷阱。</p></blockquote><h2 id="_1-变量提升现象解析" tabindex="-1"><a class="header-anchor" href="#_1-变量提升现象解析"><span>1. 变量提升现象解析</span></a></h2><h3 id="_1-1-代码执行顺序的误解" tabindex="-1"><a class="header-anchor" href="#_1-1-代码执行顺序的误解"><span>1.1 代码执行顺序的误解</span></a></h3><p>直觉上认为JavaScript代码在执行时是由上到下一行一行执行的。但实际上这并不完全正确。让我们通过几个实际的例子来理解这个特性。</p><h3 id="_1-2-变量声明后置的情况" tabindex="-1"><a class="header-anchor" href="#_1-2-变量声明后置的情况"><span>1.2 变量声明后置的情况</span></a></h3><p>思考如下代码：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line">a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">var</span> a<span class="token punctuation">;</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里会打印什么呢？</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初学者可能会认为输出是<code>undefined</code>，这是基于以下推理：</p><ol><li><code>var a</code>声明在<code>a = 2</code>之后</li><li>变量被重新声明，应该被赋予默认值<code>undefined</code></li></ol><p>但实际上，这段代码会输出<code>2</code>。这个结果暗示了JavaScript中一个重要的机制：变量提升。</p><h3 id="_1-3-变量使用前声明的情况" tabindex="-1"><a class="header-anchor" href="#_1-3-变量使用前声明的情况"><span>1.3 变量使用前声明的情况</span></a></h3><p>考虑另一个更具有迷惑性的例子：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码会输出什么？有两种常见的猜测：</p><ol><li>输出<code>2</code>（基于第一个例子的经验）</li><li>抛出错误（因为变量在使用前没有声明）</li></ol><p>然而，实际结果是：输出<code>undefined</code>。这个看似矛盾的结果，正是我们需要深入理解JavaScript变量提升机制的原因。</p><h2 id="_2-javascript提升机制的工作原理" tabindex="-1"><a class="header-anchor" href="#_2-javascript提升机制的工作原理"><span>2. JavaScript提升机制的工作原理</span></a></h2><h3 id="_2-1-编译阶段的声明处理" tabindex="-1"><a class="header-anchor" href="#_2-1-编译阶段的声明处理"><span>2.1 编译阶段的声明处理</span></a></h3><p>JavaScript代码的执行分为两个阶段：编译阶段和执行阶段。在编译阶段，JavaScript引擎会：</p><ol><li>扫描所有的代码</li><li>找到所有的变量和函数声明</li><li>将这些声明与它们各自的作用域关联起来</li></ol><p>这个过程是<code>词法作用域</code>规则的具体实现，也是变量和函数提升现象的根本原因。</p><h3 id="_2-2-声明和赋值的分离处理" tabindex="-1"><a class="header-anchor" href="#_2-2-声明和赋值的分离处理"><span>2.2 声明和赋值的分离处理</span></a></h3><p>一个关键的概念是：<code>JavaScript引擎会将变量声明和赋值操作分开处理</code>。</p><p>以<code>var a = 2;</code>为例，JavaScript引擎会将其解析为两个独立的操作：</p><ol><li><code>var a;</code> - 变量声明（在编译阶段处理）</li><li><code>a = 2;</code> - 变量赋值（在执行阶段处理）</li></ol><h3 id="_2-3-代码处理的实际过程" tabindex="-1"><a class="header-anchor" href="#_2-3-代码处理的实际过程"><span>2.3 代码处理的实际过程</span></a></h3><p>让我们通过具体例子来理解这个过程：</p><p><strong>示例1：声明后赋值</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">var</span> a<span class="token punctuation">;</span></span>
<span class="line">a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码清晰地展示了声明和赋值的分离：</p><ul><li>编译阶段：处理<code>var a;</code></li><li>执行阶段：处理<code>a = 2;</code>和<code>console.log(a);</code></li></ul><p><strong>示例2：声明和赋值的提升效果</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">var</span> a<span class="token punctuation">;</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span></span>
<span class="line">a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子展示了为什么提升看起来像是将声明&quot;移动&quot;到了代码的最前面：</p><ul><li>声明<code>var a</code>在编译阶段就被处理了</li><li>而赋值操作<code>a = 2</code>保持在原来的位置</li><li>因此<code>console.log(a)</code>时只能得到<code>undefined</code><strong>注意</strong>：只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码的执行顺序，那会造成代码运行的混乱。</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span></span>
<span class="line">	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>foo</code>函数的声明被提升了，因此在第一行调用可以正常进行。 每个作用域都会进行提升操作，<code>foo</code>函数自身会在内部对<code>var a;</code>进行提升。因此上面这段代码可以理解为如下：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">var</span> a<span class="token punctuation">;</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">	a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong>：函数声明会被提升，但是函数表达式不会被提升</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里会报错</span></span>
<span class="line"><span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这段程序中<code>foo()</code>被提升到所分配的作用域，因此<code>foo()</code>不会导致错误，但是<code>foo</code>此时还没有被赋值。<code>foo()</code>相当于<code>undefined()</code>，因此会抛出异常。 同时即使使用具名的函数表达式，名称标识符在赋值之前也无法在所在的作用域使用</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span></span>
<span class="line"><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span></span>
<span class="line"><span class="token keyword">var</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span> <span class="token comment">// 具名函数</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码可以理解为如下代码：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">var</span> foo<span class="token punctuation">;</span></span>
<span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span></span>
<span class="line"><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span></span>
<span class="line"><span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-函数提升的特殊性与最佳实践" tabindex="-1"><a class="header-anchor" href="#_3-函数提升的特殊性与最佳实践"><span>3. 函数提升的特殊性与最佳实践</span></a></h2><h3 id="_3-1-函数提升优先级" tabindex="-1"><a class="header-anchor" href="#_3-1-函数提升优先级"><span>3.1 函数提升优先级</span></a></h3><p>在JavaScript中，函数声明和变量声明都会被提升，但函数声明会被优先提升到变量声明之前。这个特性会导致一些有趣的行为：</p><p><strong>示例1：函数声明vs变量声明</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></span>
<span class="line"><span class="token keyword">var</span> foo<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码实际的执行顺序是：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">var</span> foo<span class="token punctuation">;</span> <span class="token comment">// 被忽略，因为已经有同名函数声明</span></span>
<span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></span>
<span class="line"><span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-函数声明覆盖规则" tabindex="-1"><a class="header-anchor" href="#_3-2-函数声明覆盖规则"><span>3.2 函数声明覆盖规则</span></a></h3><p>虽然重复的变量声明会被忽略，但后面的函数声明可以覆盖前面的函数声明。这可能导致意外的行为：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-3-块级函数声明的陷阱" tabindex="-1"><a class="header-anchor" href="#_3-3-块级函数声明的陷阱"><span>3.3 块级函数声明的陷阱</span></a></h3><p>在块级作用域内声明函数需要特别注意。虽然函数声明会被提升，但在不同的JavaScript环境中可能有不同的行为：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span></span>
<span class="line"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">	<span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">	<span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-4-函数提升的最佳实践" tabindex="-1"><a class="header-anchor" href="#_3-4-函数提升的最佳实践"><span>3.4 函数提升的最佳实践</span></a></h3><p>为了避免函数提升带来的问题，建议遵循以下原则：</p><ol><li><p><strong>使用函数表达式替代函数声明</strong></p><ul><li>使用<code>const</code>声明函数表达式，避免意外重新赋值</li><li>函数表达式更清晰地表达了函数的作用域</li></ul></li><li><p><strong>避免在块级作用域中使用函数声明</strong></p><ul><li>在块中使用函数表达式</li><li>如果需要条件性地定义函数，使用变量声明配合函数表达式</li></ul></li><li><p><strong>保持函数声明在作用域顶部</strong></p><ul><li>即使有提升机制，也应该将函数声明放在代码的顶部</li><li>这样可以提高代码的可读性和可维护性</li></ul></li></ol><h2 id="_4-小结" tabindex="-1"><a class="header-anchor" href="#_4-小结"><span>4. 小结</span></a></h2><p>我们可能习惯的将<code>var a = 2;</code>当做一个声明，在实际中JavaScript引擎会将<code>var a;</code>和<code>a = 2</code>当做两个单独的声明，第一个是编译阶段的任务，第二个是执行阶段的任务。 这就意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理，所有声明的变量和函数都会被<code>移动</code>到各自作用域的最顶端，这个过程就是<strong>提升</strong>。声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。 要避免重复声明，特别是当普通的var声明和函数声明混合在一起的时候，否则会引起一些意想不到的问题。</p>`,62)),t(s)])}const r=a(l,[["render",i]]),k=JSON.parse('{"path":"/notes/web/javascript/advance/%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87.html","title":"JavaScript变量和函数提升详解：原理、机制与最佳实践","lang":"zh-CN","frontmatter":{"title":"JavaScript变量和函数提升详解：原理、机制与最佳实践","meta":[{"name":"description","content":"深入解析JavaScript中变量和函数提升的工作原理，包括编译阶段处理、执行顺序、作用域规则等核心概念。通过丰富的代码示例，帮助开发者理解和避免提升机制带来的常见陷阱。"},{"name":"keywords","content":"JavaScript, 变量提升, 函数提升, hoisting, var声明, 函数声明, 作用域, 编译原理, JavaScript引擎, 词法作用域"}]},"headers":[{"level":2,"title":"1. 变量提升现象解析","slug":"_1-变量提升现象解析","link":"#_1-变量提升现象解析","children":[{"level":3,"title":"1.1 代码执行顺序的误解","slug":"_1-1-代码执行顺序的误解","link":"#_1-1-代码执行顺序的误解","children":[]},{"level":3,"title":"1.2 变量声明后置的情况","slug":"_1-2-变量声明后置的情况","link":"#_1-2-变量声明后置的情况","children":[]},{"level":3,"title":"1.3 变量使用前声明的情况","slug":"_1-3-变量使用前声明的情况","link":"#_1-3-变量使用前声明的情况","children":[]}]},{"level":2,"title":"2. JavaScript提升机制的工作原理","slug":"_2-javascript提升机制的工作原理","link":"#_2-javascript提升机制的工作原理","children":[{"level":3,"title":"2.1 编译阶段的声明处理","slug":"_2-1-编译阶段的声明处理","link":"#_2-1-编译阶段的声明处理","children":[]},{"level":3,"title":"2.2 声明和赋值的分离处理","slug":"_2-2-声明和赋值的分离处理","link":"#_2-2-声明和赋值的分离处理","children":[]},{"level":3,"title":"2.3 代码处理的实际过程","slug":"_2-3-代码处理的实际过程","link":"#_2-3-代码处理的实际过程","children":[]}]},{"level":2,"title":"3. 函数提升的特殊性与最佳实践","slug":"_3-函数提升的特殊性与最佳实践","link":"#_3-函数提升的特殊性与最佳实践","children":[{"level":3,"title":"3.1 函数提升优先级","slug":"_3-1-函数提升优先级","link":"#_3-1-函数提升优先级","children":[]},{"level":3,"title":"3.2 函数声明覆盖规则","slug":"_3-2-函数声明覆盖规则","link":"#_3-2-函数声明覆盖规则","children":[]},{"level":3,"title":"3.3 块级函数声明的陷阱","slug":"_3-3-块级函数声明的陷阱","link":"#_3-3-块级函数声明的陷阱","children":[]},{"level":3,"title":"3.4 函数提升的最佳实践","slug":"_3-4-函数提升的最佳实践","link":"#_3-4-函数提升的最佳实践","children":[]}]},{"level":2,"title":"4. 小结","slug":"_4-小结","link":"#_4-小结","children":[]}],"git":{"updatedTime":1747659450000,"contributors":[{"name":"chenshicong","username":"chenshicong","email":"chenshicong666@qq.com","commits":6,"url":"https://github.com/chenshicong"}],"changelog":[{"hash":"d78ea0ac931ae3ba09698cb79415ce6c1e5c2ac2","time":1747659450000,"email":"chenshicong666@qq.com","author":"chenshicong","message":"优化SEO"},{"hash":"feb96b39c22fb6c7c02efe9e162707273b95a33a","time":1744884521000,"email":"chenshicong666@qq.com","author":"chenshicong","message":"给文章添加标题"},{"hash":"d77eca965af30a4062cb012e254e74dae854453e","time":1744625069000,"email":"chenshicong666@qq.com","author":"chenshicong","message":"修改目录结构，加入Node的模块实现"},{"hash":"4f8aaeace2e40f47ca66bd889f3976bd3a2a2134","time":1744458825000,"email":"chenshicong666@qq.com","author":"chenshicong","message":"更新笔记分组，新增css和文档"},{"hash":"72c2f916e1d3a79325f24d7e1d371f0bfcd98131","time":1744161040000,"email":"chenshicong666@qq.com","author":"chenshicong","message":"引入评论功能"},{"hash":"6847f5a2bd77613a9564b66c6a86a8132c97d0a7","time":1744112348000,"email":"chenshicong666@qq.com","author":"chenshicong","message":"变量和函数提升"}]},"filePathRelative":"notes/web/javascript/advance/变量和函数提升.md"}');export{r as comp,k as data};
